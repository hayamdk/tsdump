#include "core/tsdump_def.h"

#ifdef TSD_PLATFORM_MSVC
	#pragma comment(lib, "Ws2_32.lib")
	#include <windows.h>
#else
	#include <errno.h>
	#include <unistd.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <signal.h>
#include <time.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <inttypes.h>
#include <stdarg.h>
#include <assert.h>

#include "utils/arib_proginfo.h"
#include "core/module_api.h"
#include "utils/arib_parser.h"
#include "utils/tsdstr.h"
#include "utils/advanced_buffer.h"
#include "utils/aribstr.h"
#include "utils/path.h"

#include "core/tsdump.h"
#include "core/load_modules.h"
#include "core/ts_output.h"

#include "core/default_decoder.h"

int BUFSIZE = BUFSIZE_DEFAULT * 1024 * 1024;
int OVERLAP_SEC = OVERLAP_SEC_DEFAULT;
int CHECK_INTERVAL = CHECK_INTERVAL_DEFAULT;
int MAX_PGOVERLAP = MAX_PGOVERLAP_DEFAULT;
int MAX_OUTPUT_DELAY_SEC = 120;
int MAX_CLOSE_DELAY_SEC = 30;

#ifdef TSD_PLATFORM_MSVC
static int use_process_priority = 0;
static DWORD process_priority;
#endif

static volatile int termflag = 0;
static volatile int termwaiting = 0;
static volatile int termedflag = 0;

int param_sp_num = -1;
int param_ch_num = -1;
int param_all_services;
unsigned int param_services[MAX_SERVICES];
int param_n_services = 0;
int param_nosplit = 0;
int param_wait_stream = 0;

int need_clear_line = 0;

#ifdef TSD_PLATFORM_MSVC

BOOL WINAPI console_ctrl_handler(DWORD ctrl)
{
	int64_t t;
	UNREF_ARG(ctrl);
	termflag = 1;
	output_message(MSG_NOTIFY, TSD_TEXT("\n終了シグナルをキャッチ"));
	while (!termwaiting) {
		Sleep(10);
	}
	t = gettime();
	while (!termedflag) {
		if (gettime() - t > 1000*20) {
			/* 20秒以上経過したら諦めて出る */
			output_message(MSG_NOTIFY, TSD_TEXT("\nモジュールのクローズに時間がかかっているため強制終了します"));
			break;
		}
		Sleep(10);
	}
	return FALSE;
}

#else

void signal_handler(int sig)
{
	UNREF_ARG(sig);
	termflag = 1;
	output_message(MSG_NOTIFY, TSD_TEXT("\n終了シグナルをキャッチ"));
}

#endif

void _output_message(const char *fname, message_type_t msgtype, const TSDCHAR *fmt, ...)
{
	va_list list;
	va_start(list, fmt);
	tsd_syserr_t lasterr, *plasterr = NULL;
	TSDCHAR msg[2048];
	const TSDCHAR *modname;

	/* 拡張子を除いたファイル名=モジュール名をコピー */
#ifdef TSD_PLATFORM_MSVC
	const char *cp;
	int len;

	if (msgtype == MSG_SYSERROR) {
		lasterr = GetLastError();
		plasterr = &lasterr;
	} else if (msgtype == MSG_WINSOCKERROR) {
		lasterr = WSAGetLastError();
		plasterr = &lasterr;
	}

	WCHAR modpath[MAX_PATH_LEN], *wcp;
		for (wcp = modpath, cp = fname;
			*cp != '\0' && *cp != '.' && wcp < &modpath[MAX_PATH_LEN];
			cp += len, wcp++) {
		len = mbtowc(wcp, cp, MB_CUR_MAX);
	}
	*wcp = L'\0';

	/* __FILE__にフルパスが入っている場合があるのでファイル名のみ取り出す */
	modname = path_getfile(modpath);
#else
	if (msgtype == MSG_SYSERROR) {
		lasterr = errno;
		plasterr = &lasterr;
	}

	/* __FILE__にフルパスが入っている場合があるのでファイル名のみ取り出す */
	modname = path_getfile(fname);
#endif

	tsd_vsnprintf(msg, 2048-1, fmt, list);
	va_end(list);

	if ( tsd_strncmp(modname, TSD_TEXT("mod_"), 4) == 0 ) {
		do_message(modname, msgtype, plasterr, msg);
	} else {
		do_message(NULL, msgtype, plasterr, msg);
	}
}

int print_services(ts_service_list_t *services_list)
{
	int i, get_service_info = 0, sid;

	for (i = 0; i < services_list->n_services; i++) {
		if ( !(services_list->proginfos[i].status & PGINFO_GET_PAT) ) {
			return 0;
		}
		if (services_list->proginfos[i].status & PGINFO_GET_SERVICE_INFO) {
			get_service_info = 1;
		}
	}
	if (!get_service_info) {
		/* 最低1サービスでもサービス情報が取得できるのを待つ */
		return 0;
	}

	output_message(MSG_DISP, TSD_TEXT("サービス数: %d"), services_list->n_services);
	for (i = 0; i < services_list->n_services; i++) {
		sid = services_list->proginfos[i].service_id;
		if (services_list->proginfos[i].status & PGINFO_GET_SERVICE_INFO) {
			output_message(MSG_DISP, TSD_TEXT("サービス%d: ID=%04x(%d), %s"), i, sid, sid, services_list->proginfos[i].service_name.str);
		} else {
			output_message(MSG_DISP, TSD_TEXT("サービス%d: ID=%04x(%d), (名称不明)"), i, sid, sid);
		}
	}
	return 1;
}

#ifdef TSD_PLATFORM_MSVC

ssize_t save_line(COORD *new_pos)
{
	CONSOLE_SCREEN_BUFFER_INFO ci;
	HANDLE hc;
	ssize_t console_width = 0;

	hc = GetStdHandle(STD_OUTPUT_HANDLE);
	if (hc != INVALID_HANDLE_VALUE) {
		if (GetConsoleScreenBufferInfo(hc, &ci) != 0) {
			if (ci.dwCursorPosition.X != 0 || ci.dwCursorPosition.Y != 0) { /* WINEだとこれを取得できない(0がセットされる) */
				console_width = ci.dwSize.X;
				new_pos->X = 0;
				new_pos->Y = ci.dwCursorPosition.Y;
				if ( ci.dwCursorPosition.Y > ci.dwSize.Y - 3 ) { /* 3行分の余白が無ければ最後に行を戻す */
					new_pos->Y = ci.dwSize.Y - 3;
				}
			}
		}
	} else {
		console_width = -1;
	}

	if (console_width >= 256) {
		console_width = 255;
	}

	return console_width;
}

void restore_line(const COORD new_pos)
{
	HANDLE hc = GetStdHandle(STD_OUTPUT_HANDLE);
	if (hc != INVALID_HANDLE_VALUE) {
		SetConsoleCursorPosition(hc, new_pos);
	}
}

void clear_line()
{
	ssize_t console_width;
	COORD new_pos;
	WCHAR line[256];
	int i;

	if (!need_clear_line) {
		return;
	}

	console_width = save_line(&new_pos);
	if (console_width > 0) {
		for (i = 0; i < console_width - 1; i++) {
			line[i] = TSD_CHAR(' ');
		}
		line[console_width - 1] = TSD_NULLCHAR;

		tsd_printf(TSD_TEXT("%s\n"), line);
		tsd_printf(TSD_TEXT("%s\n"), line);
		tsd_printf(TSD_TEXT("%s\n"), line);
		restore_line(new_pos);
	}

	need_clear_line = 0;
}

#endif

void print_buf(output_status_stream_t *tos, int n_tos, const TSDCHAR *stat)
{
#ifdef TSD_PLATFORM_MSVC
	int n, backward_size, pos_write, pos, buf_offset;
	ssize_t width, console_width;
	char line[256], hor[256];
	char *p = line;
	static int cnt = 0;
	COORD new_pos;
	time_mjd_t time_jst;
#endif
	int i, buf_used, buf_used_sv;
	double rate;

	if(!tos) {
		return;
	}

#ifdef TSD_PLATFORM_MSVC
	console_width = save_line(&new_pos);
	if (console_width < 0) {
		fprintf(stderr, "console error\r");
	} else if (console_width == 0) {
#endif
		assert(n_tos >= 1);
		ab_get_status(tos[0].ab, &buf_used, NULL);
		for (i = 1; i < n_tos; i++) {
			ab_get_status(tos[i].ab, &buf_used_sv, NULL);
			if (buf_used_sv > buf_used) {
				buf_used = buf_used_sv;
			}
		}
		rate = 100.0 * buf_used / BUFSIZE;
		tsd_printf(TSD_TEXT("%s buf:%.1f%% \r"), stat, rate);
		fflush(stdout);
#ifdef TSD_PLATFORM_MSVC
	} else {
		width = ( console_width - 6 - (n_tos-1) ) / n_tos;

		for (i = 0; i < n_tos; i++) {
			ab_get_status(tos[i].ab, &buf_used, &buf_offset);
			backward_size = ab_get_history_backward_bytes(tos[i].ab_history);

			pos_write = buf_used;
			for (n = ab_first_downstream(tos[i].ab); n >= 0; n = ab_next_downstream(tos[i].ab, n)) {
				ab_get_downstream_status(tos[i].ab, n, &pos, NULL);
				if (pos < pos_write) {
					pos_write = pos;
				}
			}

			for (n = 0; n < width; n++) {
				pos = (int)( (double)BUFSIZE / width * (n+0.5) );
				pos -= buf_offset;
				if (pos < 0) {
					pos += BUFSIZE;
				}

				if (pos < pos_write) {
					*p = '-';
				} else if (pos < buf_used) {
					*p = '!';
				} else {
					*p = '_';
				}
				if (pos > buf_used - backward_size) {
					if (*p == '-') {
						*p = '+';
					} else if(*p == '/') {
						*p = '|';
					}
				}
				p++;
			}
			if (i != n_tos - 1) {
				*(p++) = ' ';
			}
		}
		*p = '\0';

		if (get_stream_timestamp(tos->proginfo, &time_jst)) {
			snprintf(hor, sizeof(hor), "---- [%04d/%02d/%02d %02d:%02d:%02d.%03d] ",
				time_jst.year,
				time_jst.mon,
				time_jst.day,
				time_jst.hour,
				time_jst.min,
				time_jst.sec,
				time_jst.usec/1000
			);
		} else {
			snprintf(hor, sizeof(hor), "---- [UNKNOWN TIMESTAMP] ");
		}

		width = strlen(hor);
		if (console_width > width+1) {
			memset(&hor[width], '-', console_width - width - 1);
			hor[console_width - 1] = '\0';
		}

		tsd_printf(TSD_TEXT("%S\n%s\nbuf: %S"),hor, stat, line);
		restore_line(new_pos);

		need_clear_line = 1;
	}
#endif
}

static void print_stat(output_status_stream_t *tos, int n_tos, const ch_info_t *ch_info)
{
	const stream_stats_t *stats;
	TSDCHAR title[256];
	TSDCHAR siglevel_str[16], cnr_str[16];
	TSDCHAR sig_separator[2] = { TSD_NULLCHAR };

	get_stream_stats(&stats);

	if (stats->s_signal.level_scale == TSDUMP_SCALE_DECIBEL) {
		tsd_snprintf(siglevel_str, sizeof(siglevel_str) - 1, TSD_TEXT("%.1fdBm"), stats->s_signal.level);
	} else if (stats->s_signal.level_scale == TSDUMP_SCALE_RELATIVE) {
		tsd_snprintf(siglevel_str, sizeof(siglevel_str) - 1, TSD_TEXT("%.1f%%"), stats->s_signal.level*100);
	} else if (stats->s_signal.level_scale == TSDUMP_SCALE_COUNTER) {
		tsd_snprintf(siglevel_str, sizeof(siglevel_str) - 1, TSD_TEXT("%d"), (int)stats->s_signal.level);
	} else {
		siglevel_str[0] = TSD_NULLCHAR;
	}

	if (stats->s_signal.cnr_scale == TSDUMP_SCALE_DECIBEL) {
		tsd_snprintf(cnr_str, sizeof(cnr_str) - 1, TSD_TEXT("%.1fdB"), stats->s_signal.cnr);
	} else if (stats->s_signal.cnr_scale == TSDUMP_SCALE_RELATIVE) {
		tsd_snprintf(cnr_str, sizeof(cnr_str) - 1, TSD_TEXT("%.1f%%"), stats->s_signal.cnr*100);
	} else if (stats->s_signal.cnr_scale == TSDUMP_SCALE_COUNTER) {
		tsd_snprintf(cnr_str, sizeof(cnr_str) - 1, TSD_TEXT("%d"), (int)stats->s_signal.cnr);
	} else {
		cnr_str[0] = TSD_NULLCHAR;
	}

	if (siglevel_str[0] != TSD_NULLCHAR && cnr_str[0] != TSD_NULLCHAR) {
		tsd_strcpy(sig_separator, TSD_TEXT(","));
	}

	tsd_snprintf(title, 256, TSD_TEXT("%s:%s:%s|%s%s%s %.1fMbps D:%"PRId64" S:%"PRId64" %.1fGB"),
		ch_info->tuner_name, ch_info->sp_str, ch_info->ch_str, siglevel_str, sig_separator, cnr_str, stats->mbps,
		stats->s_decoder.n_dropped, stats->s_decoder.n_scrambled,
		(double)stats->total_bytes / 1024 / 1024 / 1024);
#ifdef TSD_PLATFORM_MSVC
	SetConsoleTitle(title);
#endif
	print_buf(tos, n_tos, title);
}

void init_service_list(ts_service_list_t *service_list)
{
	int i;

	service_list->n_services = 0;
	service_list->pid0x00.pid = 0;
	service_list->pid0x00.stat = PAYLOAD_STAT_INIT;
	service_list->pid0x11.pid = 0x11;
	service_list->pid0x11.stat = PAYLOAD_STAT_INIT;
	service_list->pid0x12.pid = 0x12;
	service_list->pid0x12.stat = PAYLOAD_STAT_INIT;
	service_list->pid0x14.pid = 0x14;
	service_list->pid0x14.stat = PAYLOAD_STAT_INIT;
	service_list->pid0x26.pid = 0x26;
	service_list->pid0x26.stat = PAYLOAD_STAT_INIT;
	service_list->pid0x27.pid = 0x27;
	service_list->pid0x27.stat = PAYLOAD_STAT_INIT;

	for (i = 0; i < MAX_SERVICES_PER_CH; i++) {
		init_proginfo(&service_list->proginfos[i]);
	}
}

static proginfo_t *find_curr_service(void *param, const unsigned int service_id)
{
	int i;
	ts_service_list_t *sl = (ts_service_list_t*)param;
	for (i = 0; i < sl->n_services; i++) {
		if (service_id == sl->proginfos[i].service_id) {
			return &sl->proginfos[i];
		}
	}
	return NULL;
}

static proginfo_t *find_curr_service_pcr_pid(void *param, const unsigned int pcr_pid)
{
	int i;
	ts_service_list_t *sl = (ts_service_list_t*)param;
	for (i = 0; i < sl->n_services; i++) {
		if (pcr_pid == sl->proginfos[i].PCR_pid) {
			return &sl->proginfos[i];
		}
	}
	return NULL;
}

static proginfo_t *find_curr_service_eit(void *param, const EIT_header_t *eit_h)
{
	if (eit_h->section_number != 0) {
		/* 現在進行中の番組ではない */
		return NULL;
	}
	return find_curr_service(param, eit_h->service_id);
}

static void pat_handler(void *param, const int n, const int i, const PAT_item_t *PAT_item)
{
	ts_service_list_t *sl = (ts_service_list_t*)param;
	UNREF_ARG(n);
	UNREF_ARG(i);

	if (sl->n_services >= MAX_SERVICES_PER_CH) {
		return;
	}

	if (PAT_item->program_number != 0) {
		sl->PMT_payloads[sl->n_services].stat = PAYLOAD_STAT_INIT;
		sl->PMT_payloads[sl->n_services].pid = PAT_item->pid;
		store_PAT(&sl->proginfos[sl->n_services], PAT_item);
		(sl->n_services)++;
	}
}

static void tot_handler(void *param, const time_mjd_t *TOT_time)
{
	int i;
	ts_service_list_t *sl = (ts_service_list_t*)param;

	for (i = 0; i < sl->n_services; i++) {
		store_TOT(&sl->proginfos[i], TOT_time);
	}
}

void request_shutdown(int mode)
{
	UNREF_ARG(mode);
	output_message(MSG_NOTIFY, TSD_TEXT("\nモジュールからの終了リクエスト"));
	termflag = 1;
}

void main_loop(void *generator_stat, void *decoder_stat, int encrypted, ch_info_t *ch_info)
{
	uint8_t *recvbuf, *decbuf;

	int n_recv=0, n_dec;

	int64_t total = 0;
	int64_t subtotal = 0;

	int64_t nowtime, lasttime, nowtime_base;

	output_status_stream_t *tos = NULL;
	int n_tos = 0;

	lasttime = nowtime = gettime();

	double tdiff, Mbps=0.0;

	int n, i, j;
	int single_mode = 0;

	int pos;
	int printservice = 0;
	int busy;

	ts_service_list_t service_list;

	const uint8_t *packet;
	ts_header_t tsh;

	init_service_list(&service_list);

	if ( !param_all_services && param_n_services == 0 ) {
		single_mode = 1;
	}

	do_open_stream();

	while ( !termflag ) {
		nowtime_base = gettime();

		/* 最大100回まで連続して取得を試みる */
		for(n = 0; n < 100; n++) {
			if (n_recv == 0) {
				/* 前回の取得サイズが0だった場合はストリームの到着を待つ */
				if (do_stream_generator_wait(generator_stat, 100) < 0) {
					/* 待ち機能に非対応なストリームジェネレータの場合10ms待つ */
#ifdef TSD_PLATFORM_MSVC
					Sleep(10);
#else
					usleep(10*1000);
#endif
				}
			}

			do_stream_generator(generator_stat, &recvbuf, &n_recv);
			do_encrypted_stream(recvbuf, n_recv);

			do_stream_decoder(decoder_stat, &decbuf, &n_dec, recvbuf, n_recv);
			do_stream(decbuf, n_dec, encrypted);

			add_stream_stats_total_bytes(n_recv);

			nowtime = gettime();

			int valid_ts_header;
			int need_default_counter = !(is_implemented_stream_decoder_stats());

			for (i = 0; i < n_dec; i+=188) {
				packet = &decbuf[i];
				valid_ts_header = parse_ts_header(packet, &tsh);

				if (need_default_counter) {
					if (!valid_ts_header) {
						ts_packet_counter(NULL);
					} else {
						ts_packet_counter(&tsh);
					}
				}

				if (tsh.transport_scrambling_control) {
					continue;
				}

				if (!valid_ts_header) {
					if (tsh.valid_sync_byte) {
						/* PESパケットでここに来る場合があるので警告はひとまずOFF  e.g. NHK BS1
						   PESパケットの規格を要調査 */
						//output_message(MSG_PACKETERROR, L"Invalid ts header! pid=0x%x(%d)", tsh.pid, tsh.pid);
					} else {
						output_message(MSG_PACKETERROR, TSD_TEXT("Invalid ts packet!"));
					}
					continue; /* pass */
				}

				if (service_list.n_services == 0) {
					/* PATの取得は初回のみ */
					parse_PAT(&service_list.pid0x00, packet, &tsh, &service_list, pat_handler);
				} else {
					for (j = 0; j < service_list.n_services; j++) {
						parse_PMT(packet, &tsh, &service_list.PMT_payloads[j], &service_list.proginfos[j]);
					}
					if (!printservice) {
						printservice = print_services(&service_list);
						if(printservice) {
							ts_n_drops = 0;
							ts_n_total = 0;
							ts_n_scrambled = 0;
						}
					}
				}
				parse_PCR(packet, &tsh, &service_list, find_curr_service_pcr_pid);
				parse_TOT_TDT(packet, &tsh, &service_list.pid0x14, &service_list, tot_handler);
				parse_SDT(&service_list.pid0x11, packet, &tsh, &service_list, find_curr_service);

				if (!param_nosplit) {
					parse_EIT(&service_list.pid0x12, packet, &tsh, &service_list, find_curr_service_eit);
					parse_EIT(&service_list.pid0x26, packet, &tsh, &service_list, find_curr_service_eit);
					parse_EIT(&service_list.pid0x27, packet, &tsh, &service_list, find_curr_service_eit);
				}
			}

			if ( single_mode ) { /* 単一書き出しモード */
				/* tosを生成 */
				if ( ! tos ) {
					n_tos = param_n_services = 1;
					tos = (output_status_stream_t*)malloc(1 * sizeof(output_status_stream_t));
					init_tos(tos);
					tos->proginfo = &service_list.proginfos[0];
				}

				/* パケットをバッファにコピー */
				ab_input_buf(tos->ab, decbuf, n_dec);

			} else {  /* サービスごと書き出しモード */
				/* パケットを処理 */
				for (pos = 0; pos < (int)n_dec; pos += 188) {
					packet = &decbuf[pos];

					/* PAT, PMTを取得 */
					//parse_ts_packet(&tps, packet);

					/* tosを生成 */
					if ( ! tos && service_list.pid0x00.stat == PAYLOAD_STAT_FINISHED ) {
						n_tos = create_tos_per_service(&tos, &service_list, ch_info);
					}

					/* サービスごとにパケットをバッファにコピー */
					for (i = 0; i < n_tos; i++) {
						copy_current_service_packet(&tos[i], &service_list, packet);
					}
				}
			}

			subtotal += n_dec;
			total += n_dec;

			if (n_recv == 0 || nowtime - nowtime_base > 50) {
				break;
			}
		}

		do_tick(nowtime);

		for (i = 0; i < n_tos; i++) {
			ts_output(&tos[i], nowtime);
		}

		/* 定期的に番組情報をチェック */
		if ( nowtime / CHECK_INTERVAL != lasttime / CHECK_INTERVAL ) {

			tdiff = (double)(nowtime - lasttime) / 1000;
			Mbps = (double)subtotal * 8 / 1024 / 1024 / tdiff;

			do_stream_decoder_stats(decoder_stat);
			do_stream_generator_siglevel(generator_stat);
			do_stream_generator_cnr(generator_stat);
			set_stream_stats_mbps(Mbps);

			lasttime = nowtime;
			subtotal = 0;

			/* 番組情報のチェック */
			for (i = 0; i < n_tos; i++) {
				if (param_nosplit) {
					ts_check_si(&tos[i], nowtime, ch_info);
					continue;
				}
				if (ab_get_history_bytes(tos[i].ab_history, 0) > 0) { /* 前のintervalで何も受信できてない時は番組情報のチェックをパスする */
					ts_check_pi(&tos[i], nowtime, ch_info);
				}
			}

			print_stat(tos, n_tos, ch_info);
		}
	}

	do_close_stream();

	/* 終了処理 */
	output_message(MSG_NOTIFY, TSD_TEXT("まだ書き出していないバッファを書き出ています"));
	do_preclose_module();
	for (i = 0; i < n_tos; i++) {
		prepare_close_tos(&tos[i]);
	}

	busy = 1;
	while (busy) {
		busy = 0;
		for (i = 0; i < n_tos; i++) {
			ts_output(&tos[i], gettime());
			busy |= (tos[i].n_pgos > 0);
		}

#ifdef TSD_PLATFORM_MSVC
		Sleep(100);
#else
		usleep(100 * 1000);
#endif
	}

	termwaiting = 1;
	for (i = 0; i < n_tos; i++) {
		close_tos(&tos[i]);
	}
	do_close_module();
	free(tos);
}

#ifdef TSD_PLATFORM_MSVC
int wmain(int argc, const WCHAR* argv[])
#else
int main(int argc, const char* argv[])
#endif
{
	int ret=0;
	ch_info_t ch_info;
	void *generator_stat = NULL;
	void *decoder_stat = NULL;
	int encrypted;

#ifdef TSD_PLATFORM_MSVC
	_wsetlocale(LC_ALL, L"Japanese_Japan.932");
#endif

	output_message(MSG_NONE, TSD_TEXT("tsdump ver%s (%s)\n"), VERSION_STR, DATE_STR);

	/* モジュールをロード */
	if (load_modules() < 0) {
		output_message(MSG_ERROR, TSD_TEXT("モジュールのロード時にエラーが発生しました!"));
		ret = 1;
		goto END;
	}

	/* モジュールを初期化 */
	if ( !init_modules(argc, argv) ) {
		output_message(MSG_ERROR, TSD_TEXT("モジュールの初期化時にエラーが発生しました!"));
		print_cmd_usage();
		ret = 1;
		goto END;
	}

	output_message(MSG_NONE, TSD_TEXT("BUFSIZE: %dMiB\nOVERLAP_SEC: %ds\nCHECK_INTERVAL: %dms\nMAX_PGOVERLAP: %d\n"),
		BUFSIZE / 1024 / 1024, OVERLAP_SEC, CHECK_INTERVAL, MAX_PGOVERLAP);

#ifdef TSD_PLATFORM_MSVC
	SetConsoleCtrlHandler(console_ctrl_handler, TRUE);
#else
	signal(SIGINT, signal_handler);
	signal(SIGTERM, signal_handler);
#endif

	while ( !do_stream_generator_open(&generator_stat, &ch_info) ) {
		if (param_wait_stream) {
			output_message(MSG_ERROR, TSD_TEXT("ストリームジェネレータを開けませんでしたが10秒後再試行します"));
			#ifdef TSD_PLATFORM_MSVC
						Sleep(10*1000);
			#else
						usleep(10*1000*1000);
			#endif
		} else {
			output_message(MSG_ERROR, TSD_TEXT("ストリームジェネレータを開けませんでした"));
			ret = 1;
			goto END;
		}
	}

	ch_info.mode_all_services = param_all_services;
	ch_info.n_services = param_n_services;
	ch_info.services = param_services;

	if ( ! do_stream_decoder_open(&decoder_stat, &encrypted) ) {
		output_message(MSG_ERROR, TSD_TEXT("ストリームデコーダを開けませんでした"));
		ret = 1;
		goto END1;
	}

#ifdef TSD_PLATFORM_MSVC
	if (use_process_priority) {
		if (SetPriorityClass(GetCurrentProcess(), process_priority) == 0) {
			output_message(MSG_ERROR, TSD_TEXT("プロセスの優先度の設定に失敗しました"));
		}
	}
#endif

	/* 処理の本体 */
	main_loop(generator_stat, decoder_stat, encrypted, &ch_info);

	//printf("正常終了\n");
	output_message(MSG_NONE, TSD_TEXT("正常終了"));

	do_stream_decoder_close(decoder_stat);

END1:
	do_stream_generator_close(generator_stat);
	//fclose(fp);

END:
	do_close_module();

	free_modules();

	if( ret ) {
		output_message(MSG_NOTIFY, TSD_TEXT("\nエンターキーを押すと終了します"));
		getchar();
	}

	termedflag = 1;
	return ret;
}

static const TSDCHAR* set_sv(const TSDCHAR *param)
{
	int sv;
	if (param_all_services) {
		return NULL;
	}
	if ( tsd_strcmp(param, TSD_TEXT("all")) == 0 ) {
		param_all_services = 1;
	} else {
		if (param_n_services < MAX_SERVICES) {
			sv = tsd_atoi(param);
			if (sv <= 0 || sv > 65535) {
				return TSD_TEXT("サービス番号が不正です");
			}
			param_services[param_n_services] = sv;
			param_n_services++;
		} else {
			return TSD_TEXT("指定するサービスの数が多すぎます\n");
		}
	}
	return NULL;
}

static const TSDCHAR* set_bufsize(const TSDCHAR *param)
{
	int bs = tsd_atoi(param);
	if (bs <= 0) {
		return TSD_TEXT("不正なバッファサイズが指定されました");
	}
	BUFSIZE = bs * 1024 * 1024;
	return NULL;
}

static const TSDCHAR* set_pginterval(const TSDCHAR *param)
{
	int i = tsd_atoi(param);
	if (i <= 0 || i > 1000) {
		return TSD_TEXT("不正なインターバル時間が指定されました");
	}
	CHECK_INTERVAL = i;
	return NULL;
}

static const TSDCHAR* set_pgmargin(const TSDCHAR *param)
{
	int i = tsd_atoi(param);
	if (i <= 0 || i > 60) {
		return TSD_TEXT("不正なマージン時間が指定されました");
	}
	OVERLAP_SEC = i;
	return NULL;
}

static const TSDCHAR* set_output_delay(const TSDCHAR *param)
{
	int od = tsd_atoi(param);
	if (od <= 0) {
		return TSD_TEXT("出力の最大遅延時間に不正な値が指定されました");
	}
	MAX_OUTPUT_DELAY_SEC = od;
	return NULL;
}

static const TSDCHAR* set_close_delay(const TSDCHAR *param)
{
	int cd = tsd_atoi(param);
	if (cd <= 0) {
		return TSD_TEXT("終了処理の最大遅延時間に不正な値が指定されました");
	}
	MAX_CLOSE_DELAY_SEC = cd;
	return NULL;
}

static const TSDCHAR* set_nosplit(const TSDCHAR *param)
{
	UNREF_ARG(param);
	param_nosplit = 1;
	return NULL;
}

static const TSDCHAR* set_wait_stream(const TSDCHAR* param)
{
	UNREF_ARG(param);
	param_wait_stream = 1;
	return NULL;
}

#ifdef TSD_PLATFORM_MSVC

static const TSDCHAR* set_pri(const TSDCHAR *param)
{
	if (tsd_strcmp(param, TSD_TEXT("realtime")) == 0) {
		process_priority = REALTIME_PRIORITY_CLASS;
	} else if(tsd_strcmp(param, TSD_TEXT("high")) == 0) {
		process_priority = HIGH_PRIORITY_CLASS;
	} else if(tsd_strcmp(param, TSD_TEXT("above")) == 0) {
		process_priority = ABOVE_NORMAL_PRIORITY_CLASS;
	} else if(tsd_strcmp(param, TSD_TEXT("normal")) == 0) {
		process_priority = NORMAL_PRIORITY_CLASS;
	} else if(tsd_strcmp(param, TSD_TEXT("below")) == 0) {
		process_priority = BELOW_NORMAL_PRIORITY_CLASS;
	} else if(tsd_strcmp(param, TSD_TEXT("idle")) == 0) {
		process_priority = IDLE_PRIORITY_CLASS;
	} else {
		return TSD_TEXT("プロセスの優先度として不正な文字列が指定されました");
	}
	use_process_priority = 1;
	return NULL;
}

#endif

void ghook_message(const TSDCHAR *modname, message_type_t msgtype, tsd_syserr_t *err, const TSDCHAR *msg)
{
	const TSDCHAR *msgtype_str = TSD_TEXT("");
	FILE *fp = stdout;
	TSDCHAR msgbuf[256];
	int errtype = 0;

#ifdef TSD_PLATFORM_MSVC
	clear_line();
#endif

	if ( msgtype == MSG_WARNING || msgtype == MSG_PACKETERROR ) {
		msgtype_str = TSD_TEXT("[WARNING] ");
		fp = stderr;
		errtype = 1;
	} else if ( msgtype == MSG_ERROR || msgtype == MSG_SYSERROR || msgtype == MSG_WINSOCKERROR ) {
		msgtype_str = TSD_TEXT("[ERROR] ");
		fp = stderr;
		errtype = 1;
	}

	if ( msgtype == MSG_SYSERROR || msgtype == MSG_WINSOCKERROR ) {
#ifdef TSD_PLATFORM_MSVC
		FormatMessage(
			/*FORMAT_MESSAGE_ALLOCATE_BUFFER |*/
			FORMAT_MESSAGE_FROM_SYSTEM |
			FORMAT_MESSAGE_IGNORE_INSERTS |
			FORMAT_MESSAGE_MAX_WIDTH_MASK,
			NULL,
			*err,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			msgbuf,
			256,
			NULL
		);

		if (msgbuf[wcslen(msgbuf)-1] == L' ') {
			msgbuf[wcslen(msgbuf)-1] = L'\0';
		}
#else
		strerror_r(*err, msgbuf, 256);
#endif

		if (modname && errtype) {
			tsd_fprintf(fp, TSD_TEXT("%s(%s): %s <0x%x:%s>\n"), msgtype_str, modname, msg, *err, msgbuf);
		} else {
			tsd_fprintf(fp, TSD_TEXT("%s%s <0x%x:%s>\n"), msgtype_str, msg, *err, msgbuf);
		}
	} else {
		if (modname && errtype) {
			tsd_fprintf(fp, TSD_TEXT("%s(%s): %s\n"), msgtype_str, modname, msg);
		} else {
			tsd_fprintf(fp, TSD_TEXT("%s%s\n"), msgtype_str, msg);
		}
	}
}

static void register_hooks()
{
	//register_hook_message(hook_message);
}

static cmd_def_t cmds[] = {
	{ TSD_TEXT("--sv"), TSD_TEXT("サービス番号(複数指定可能)"), 1, set_sv },
	{ TSD_TEXT("--bufsize"), TSD_TEXT("バッファサイズを指定(MiB)"), 1, set_bufsize },
	{ TSD_TEXT("--pginterval"), TSD_TEXT("番組情報チェックのインターバル(ms)"), 1, set_pginterval },
	{ TSD_TEXT("--pgmargin"), TSD_TEXT("番組録画の前後マージン(sec)"), 1, set_pgmargin },
	{ TSD_TEXT("--max-output-delay"), TSD_TEXT("出力の最大遅延時間(sec)"), 1, set_output_delay },
	{ TSD_TEXT("--max-close-delay"), TSD_TEXT("終了処理の最大遅延時間(sec)"), 1, set_close_delay },
	{ TSD_TEXT("--nosplit"), TSD_TEXT("番組ごとに分割しない"), 0, set_nosplit },
	{ TSD_TEXT("--wait-stream"), TSD_TEXT("ストリームを開けるまで待機する"), 0, set_wait_stream },
#ifdef TSD_PLATFORM_MSVC
	{ TSD_TEXT("--pri"), TSD_TEXT("プロセスの優先度(realtime|high|above|normal|below|idle)"), 1, set_pri },
#endif
	{ NULL },
};

TSD_MODULE_DEF(
	mod_core,
	register_hooks,
	cmds,
	NULL
);
